/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kOperationValues[] = {
  Operation::CLOSE,
  Operation::START,
  Operation::RESTART,
  Operation::LOAD_DATA
};
const char* _kOperationNames[] = {
  "CLOSE",
  "START",
  "RESTART",
  "LOAD_DATA"
};
const std::map<int, const char*> _Operation_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kOperationValues, _kOperationNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStatusValues[] = {
  Status::CLOSING,
  Status::CLOSED,
  Status::OPENING,
  Status::OPENED,
  Status::DEAD
};
const char* _kStatusNames[] = {
  "CLOSING",
  "CLOSED",
  "OPENING",
  "OPENED",
  "DEAD"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOperationStatusValues[] = {
  OperationStatus::NORMAL,
  OperationStatus::IDLE,
  OperationStatus::BUSY
};
const char* _kOperationStatusNames[] = {
  "NORMAL",
  "IDLE",
  "BUSY"
};
const std::map<int, const char*> _OperationStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOperationStatusValues, _kOperationStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGameStatusValues[] = {
  GameStatus::READY,
  GameStatus::OPEN,
  GameStatus::CLOSING,
  GameStatus::CLOSED
};
const char* _kGameStatusNames[] = {
  "READY",
  "OPEN",
  "CLOSING",
  "CLOSED"
};
const std::map<int, const char*> _GameStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kGameStatusValues, _kGameStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGameStepValues[] = {
  GameStep::INNER_TEST,
  GameStep::OUTER_TEST,
  GameStep::NOMAL
};
const char* _kGameStepNames[] = {
  "INNER_TEST",
  "OUTER_TEST",
  "NOMAL"
};
const std::map<int, const char*> _GameStep_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kGameStepValues, _kGameStepNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSystemNoticeTypeValues[] = {
  SystemNoticeType::NOTICE,
  SystemNoticeType::ACTIVITY,
  SystemNoticeType::ITEMORDER,
  SystemNoticeType::SIGNIN,
  SystemNoticeType::STOREITEM,
  SystemNoticeType::CONFIG
};
const char* _kSystemNoticeTypeNames[] = {
  "NOTICE",
  "ACTIVITY",
  "ITEMORDER",
  "SIGNIN",
  "STOREITEM",
  "CONFIG"
};
const std::map<int, const char*> _SystemNoticeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kSystemNoticeTypeValues, _kSystemNoticeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOperateTypeValues[] = {
  OperateType::ADD,
  OperateType::DEL,
  OperateType::EDIT,
  OperateType::HANDLED
};
const char* _kOperateTypeNames[] = {
  "ADD",
  "DEL",
  "EDIT",
  "HANDLED"
};
const std::map<int, const char*> _OperateType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kOperateTypeValues, _kOperateTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kOperateStatusValues[] = {
  OperateStatus::UNSTART,
  OperateStatus::DOING,
  OperateStatus::COMPLETED
};
const char* _kOperateStatusNames[] = {
  "UNSTART",
  "DOING",
  "COMPLETED"
};
const std::map<int, const char*> _OperateStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOperateStatusValues, _kOperateStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kChangeStatusValues[] = {
  ChangeStatus::UNCHANGE,
  ChangeStatus::CHANGED
};
const char* _kChangeStatusNames[] = {
  "UNCHANGE",
  "CHANGED"
};
const std::map<int, const char*> _ChangeStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kChangeStatusValues, _kChangeStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMailTypeValues[] = {
  MailType::NOMAL,
  MailType::NOTICE
};
const char* _kMailTypeNames[] = {
  "NOMAL",
  "NOTICE"
};
const std::map<int, const char*> _MailType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMailTypeValues, _kMailTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kConfigTypeValues[] = {
  ConfigType::ACTIVITY
};
const char* _kConfigTypeNames[] = {
  "ACTIVITY"
};
const std::map<int, const char*> _ConfigType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kConfigTypeValues, _kConfigTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


HandleResult::~HandleResult() throw() {
}


void HandleResult::__set_operateStatus(const OperateStatus::type val) {
  this->operateStatus = val;
}

void HandleResult::__set_changeStatus(const ChangeStatus::type val) {
  this->changeStatus = val;
}

void HandleResult::__set_mess(const std::string& val) {
  this->mess = val;
__isset.mess = true;
}

void HandleResult::__set_code(const int32_t val) {
  this->code = val;
__isset.code = true;
}

uint32_t HandleResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->operateStatus = (OperateStatus::type)ecast0;
          this->__isset.operateStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->changeStatus = (ChangeStatus::type)ecast1;
          this->__isset.changeStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mess);
          this->__isset.mess = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HandleResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HandleResult");

  xfer += oprot->writeFieldBegin("operateStatus", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->operateStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changeStatus", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->changeStatus);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.mess) {
    xfer += oprot->writeFieldBegin("mess", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mess);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.code) {
    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->code);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HandleResult &a, HandleResult &b) {
  using ::std::swap;
  swap(a.operateStatus, b.operateStatus);
  swap(a.changeStatus, b.changeStatus);
  swap(a.mess, b.mess);
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

HandleResult::HandleResult(const HandleResult& other2) {
  operateStatus = other2.operateStatus;
  changeStatus = other2.changeStatus;
  mess = other2.mess;
  code = other2.code;
  __isset = other2.__isset;
}
HandleResult& HandleResult::operator=(const HandleResult& other3) {
  operateStatus = other3.operateStatus;
  changeStatus = other3.changeStatus;
  mess = other3.mess;
  code = other3.code;
  __isset = other3.__isset;
  return *this;
}
void HandleResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HandleResult(";
  out << "operateStatus=" << to_string(operateStatus);
  out << ", " << "changeStatus=" << to_string(changeStatus);
  out << ", " << "mess="; (__isset.mess ? (out << to_string(mess)) : (out << "<null>"));
  out << ", " << "code="; (__isset.code ? (out << to_string(code)) : (out << "<null>"));
  out << ")";
}


SystemNotice::~SystemNotice() throw() {
}


void SystemNotice::__set_content(const std::string& val) {
  this->content = val;
__isset.content = true;
}

void SystemNotice::__set_resourceType(const SystemNoticeType::type val) {
  this->resourceType = val;
}

void SystemNotice::__set_roleId(const std::string& val) {
  this->roleId = val;
__isset.roleId = true;
}

void SystemNotice::__set_accId(const int64_t val) {
  this->accId = val;
__isset.accId = true;
}

void SystemNotice::__set_operateType(const OperateType::type val) {
  this->operateType = val;
}

uint32_t SystemNotice::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->resourceType = (SystemNoticeType::type)ecast4;
          this->__isset.resourceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleId);
          this->__isset.roleId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->accId);
          this->__isset.accId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->operateType = (OperateType::type)ecast5;
          this->__isset.operateType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SystemNotice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SystemNotice");

  if (this->__isset.content) {
    xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->content);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("resourceType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->resourceType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.roleId) {
    xfer += oprot->writeFieldBegin("roleId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->roleId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.accId) {
    xfer += oprot->writeFieldBegin("accId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->accId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("operateType", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->operateType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SystemNotice &a, SystemNotice &b) {
  using ::std::swap;
  swap(a.content, b.content);
  swap(a.resourceType, b.resourceType);
  swap(a.roleId, b.roleId);
  swap(a.accId, b.accId);
  swap(a.operateType, b.operateType);
  swap(a.__isset, b.__isset);
}

SystemNotice::SystemNotice(const SystemNotice& other6) {
  content = other6.content;
  resourceType = other6.resourceType;
  roleId = other6.roleId;
  accId = other6.accId;
  operateType = other6.operateType;
  __isset = other6.__isset;
}
SystemNotice& SystemNotice::operator=(const SystemNotice& other7) {
  content = other7.content;
  resourceType = other7.resourceType;
  roleId = other7.roleId;
  accId = other7.accId;
  operateType = other7.operateType;
  __isset = other7.__isset;
  return *this;
}
void SystemNotice::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SystemNotice(";
  out << "content="; (__isset.content ? (out << to_string(content)) : (out << "<null>"));
  out << ", " << "resourceType=" << to_string(resourceType);
  out << ", " << "roleId="; (__isset.roleId ? (out << to_string(roleId)) : (out << "<null>"));
  out << ", " << "accId="; (__isset.accId ? (out << to_string(accId)) : (out << "<null>"));
  out << ", " << "operateType=" << to_string(operateType);
  out << ")";
}


MachineConfig::~MachineConfig() throw() {
}


void MachineConfig::__set_ip(const std::string& val) {
  this->ip = val;
}

void MachineConfig::__set_port(const int32_t val) {
  this->port = val;
}

void MachineConfig::__set_user(const std::string& val) {
  this->user = val;
}

void MachineConfig::__set_pwd(const std::string& val) {
  this->pwd = val;
}

uint32_t MachineConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pwd);
          this->__isset.pwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MachineConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MachineConfig");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pwd", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->pwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MachineConfig &a, MachineConfig &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.user, b.user);
  swap(a.pwd, b.pwd);
  swap(a.__isset, b.__isset);
}

MachineConfig::MachineConfig(const MachineConfig& other8) {
  ip = other8.ip;
  port = other8.port;
  user = other8.user;
  pwd = other8.pwd;
  __isset = other8.__isset;
}
MachineConfig& MachineConfig::operator=(const MachineConfig& other9) {
  ip = other9.ip;
  port = other9.port;
  user = other9.user;
  pwd = other9.pwd;
  __isset = other9.__isset;
  return *this;
}
void MachineConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MachineConfig(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ", " << "user=" << to_string(user);
  out << ", " << "pwd=" << to_string(pwd);
  out << ")";
}


GameServerInfo::~GameServerInfo() throw() {
}


void GameServerInfo::__set_name(const std::string& val) {
  this->name = val;
}

void GameServerInfo::__set_serverId(const int64_t val) {
  this->serverId = val;
}

void GameServerInfo::__set_operationStatus(const OperationStatus::type val) {
  this->operationStatus = val;
}

void GameServerInfo::__set_status(const Status::type val) {
  this->status = val;
}

void GameServerInfo::__set_currentCnt(const int32_t val) {
  this->currentCnt = val;
__isset.currentCnt = true;
}

void GameServerInfo::__set_configure(const MachineConfig& val) {
  this->configure = val;
__isset.configure = true;
}

uint32_t GameServerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->serverId);
          this->__isset.serverId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->operationStatus = (OperationStatus::type)ecast10;
          this->__isset.operationStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->status = (Status::type)ecast11;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->currentCnt);
          this->__isset.currentCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->configure.read(iprot);
          this->__isset.configure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GameServerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GameServerInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->serverId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operationStatus", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->operationStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.currentCnt) {
    xfer += oprot->writeFieldBegin("currentCnt", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->currentCnt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configure) {
    xfer += oprot->writeFieldBegin("configure", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->configure.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GameServerInfo &a, GameServerInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.serverId, b.serverId);
  swap(a.operationStatus, b.operationStatus);
  swap(a.status, b.status);
  swap(a.currentCnt, b.currentCnt);
  swap(a.configure, b.configure);
  swap(a.__isset, b.__isset);
}

GameServerInfo::GameServerInfo(const GameServerInfo& other12) {
  name = other12.name;
  serverId = other12.serverId;
  operationStatus = other12.operationStatus;
  status = other12.status;
  currentCnt = other12.currentCnt;
  configure = other12.configure;
  __isset = other12.__isset;
}
GameServerInfo& GameServerInfo::operator=(const GameServerInfo& other13) {
  name = other13.name;
  serverId = other13.serverId;
  operationStatus = other13.operationStatus;
  status = other13.status;
  currentCnt = other13.currentCnt;
  configure = other13.configure;
  __isset = other13.__isset;
  return *this;
}
void GameServerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GameServerInfo(";
  out << "name=" << to_string(name);
  out << ", " << "serverId=" << to_string(serverId);
  out << ", " << "operationStatus=" << to_string(operationStatus);
  out << ", " << "status=" << to_string(status);
  out << ", " << "currentCnt="; (__isset.currentCnt ? (out << to_string(currentCnt)) : (out << "<null>"));
  out << ", " << "configure="; (__isset.configure ? (out << to_string(configure)) : (out << "<null>"));
  out << ")";
}


MailInfo::~MailInfo() throw() {
}


void MailInfo::__set_title(const std::string& val) {
  this->title = val;
}

void MailInfo::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void MailInfo::__set_content(const std::string& val) {
  this->content = val;
}

void MailInfo::__set_createTime(const int64_t val) {
  this->createTime = val;
}

void MailInfo::__set_isAttach(const bool val) {
  this->isAttach = val;
}

void MailInfo::__set_attachInfo(const std::string& val) {
  this->attachInfo = val;
__isset.attachInfo = true;
}

void MailInfo::__set_type(const MailType::type val) {
  this->type = val;
}

void MailInfo::__set_senderId(const std::string& val) {
  this->senderId = val;
__isset.senderId = true;
}

void MailInfo::__set_recieverId(const std::vector<std::string> & val) {
  this->recieverId = val;
__isset.recieverId = true;
}

void MailInfo::__set_config(const std::string& val) {
  this->config = val;
__isset.config = true;
}

uint32_t MailInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAttach);
          this->__isset.isAttach = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attachInfo);
          this->__isset.attachInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->type = (MailType::type)ecast14;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->senderId);
          this->__isset.senderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->recieverId.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->recieverId.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readString(this->recieverId[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.recieverId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MailInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MailInfo");

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAttach", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->isAttach);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.attachInfo) {
    xfer += oprot->writeFieldBegin("attachInfo", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->attachInfo);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.senderId) {
    xfer += oprot->writeFieldBegin("senderId", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->senderId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.recieverId) {
    xfer += oprot->writeFieldBegin("recieverId", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->recieverId.size()));
      std::vector<std::string> ::const_iterator _iter20;
      for (_iter20 = this->recieverId.begin(); _iter20 != this->recieverId.end(); ++_iter20)
      {
        xfer += oprot->writeString((*_iter20));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config) {
    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->config);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MailInfo &a, MailInfo &b) {
  using ::std::swap;
  swap(a.title, b.title);
  swap(a.id, b.id);
  swap(a.content, b.content);
  swap(a.createTime, b.createTime);
  swap(a.isAttach, b.isAttach);
  swap(a.attachInfo, b.attachInfo);
  swap(a.type, b.type);
  swap(a.senderId, b.senderId);
  swap(a.recieverId, b.recieverId);
  swap(a.config, b.config);
  swap(a.__isset, b.__isset);
}

MailInfo::MailInfo(const MailInfo& other21) {
  title = other21.title;
  id = other21.id;
  content = other21.content;
  createTime = other21.createTime;
  isAttach = other21.isAttach;
  attachInfo = other21.attachInfo;
  type = other21.type;
  senderId = other21.senderId;
  recieverId = other21.recieverId;
  config = other21.config;
  __isset = other21.__isset;
}
MailInfo& MailInfo::operator=(const MailInfo& other22) {
  title = other22.title;
  id = other22.id;
  content = other22.content;
  createTime = other22.createTime;
  isAttach = other22.isAttach;
  attachInfo = other22.attachInfo;
  type = other22.type;
  senderId = other22.senderId;
  recieverId = other22.recieverId;
  config = other22.config;
  __isset = other22.__isset;
  return *this;
}
void MailInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MailInfo(";
  out << "title=" << to_string(title);
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "content=" << to_string(content);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "isAttach=" << to_string(isAttach);
  out << ", " << "attachInfo="; (__isset.attachInfo ? (out << to_string(attachInfo)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "senderId="; (__isset.senderId ? (out << to_string(senderId)) : (out << "<null>"));
  out << ", " << "recieverId="; (__isset.recieverId ? (out << to_string(recieverId)) : (out << "<null>"));
  out << ", " << "config="; (__isset.config ? (out << to_string(config)) : (out << "<null>"));
  out << ")";
}


CommandInfo::~CommandInfo() throw() {
}


void CommandInfo::__set_roleId(const std::string& val) {
  this->roleId = val;
}

void CommandInfo::__set_command(const std::string& val) {
  this->command = val;
}

void CommandInfo::__set_cmdArgs(const std::vector<std::string> & val) {
  this->cmdArgs = val;
}

void CommandInfo::__set_operateRoleId(const std::string& val) {
  this->operateRoleId = val;
}

void CommandInfo::__set_cmdId(const int64_t val) {
  this->cmdId = val;
}

uint32_t CommandInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleId);
          this->__isset.roleId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->command);
          this->__isset.command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cmdArgs.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->cmdArgs.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readString(this->cmdArgs[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cmdArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operateRoleId);
          this->__isset.operateRoleId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cmdId);
          this->__isset.cmdId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommandInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommandInfo");

  xfer += oprot->writeFieldBegin("roleId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("command", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->command);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmdArgs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cmdArgs.size()));
    std::vector<std::string> ::const_iterator _iter28;
    for (_iter28 = this->cmdArgs.begin(); _iter28 != this->cmdArgs.end(); ++_iter28)
    {
      xfer += oprot->writeString((*_iter28));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operateRoleId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->operateRoleId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmdId", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->cmdId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommandInfo &a, CommandInfo &b) {
  using ::std::swap;
  swap(a.roleId, b.roleId);
  swap(a.command, b.command);
  swap(a.cmdArgs, b.cmdArgs);
  swap(a.operateRoleId, b.operateRoleId);
  swap(a.cmdId, b.cmdId);
  swap(a.__isset, b.__isset);
}

CommandInfo::CommandInfo(const CommandInfo& other29) {
  roleId = other29.roleId;
  command = other29.command;
  cmdArgs = other29.cmdArgs;
  operateRoleId = other29.operateRoleId;
  cmdId = other29.cmdId;
  __isset = other29.__isset;
}
CommandInfo& CommandInfo::operator=(const CommandInfo& other30) {
  roleId = other30.roleId;
  command = other30.command;
  cmdArgs = other30.cmdArgs;
  operateRoleId = other30.operateRoleId;
  cmdId = other30.cmdId;
  __isset = other30.__isset;
  return *this;
}
void CommandInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommandInfo(";
  out << "roleId=" << to_string(roleId);
  out << ", " << "command=" << to_string(command);
  out << ", " << "cmdArgs=" << to_string(cmdArgs);
  out << ", " << "operateRoleId=" << to_string(operateRoleId);
  out << ", " << "cmdId=" << to_string(cmdId);
  out << ")";
}


RoleInfo::~RoleInfo() throw() {
}


void RoleInfo::__set_areaId(const int32_t val) {
  this->areaId = val;
}

void RoleInfo::__set_isOnline(const bool val) {
  this->isOnline = val;
}

void RoleInfo::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t RoleInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->areaId);
          this->__isset.areaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isOnline);
          this->__isset.isOnline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RoleInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RoleInfo");

  xfer += oprot->writeFieldBegin("areaId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->areaId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isOnline", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isOnline);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RoleInfo &a, RoleInfo &b) {
  using ::std::swap;
  swap(a.areaId, b.areaId);
  swap(a.isOnline, b.isOnline);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

RoleInfo::RoleInfo(const RoleInfo& other31) {
  areaId = other31.areaId;
  isOnline = other31.isOnline;
  name = other31.name;
  __isset = other31.__isset;
}
RoleInfo& RoleInfo::operator=(const RoleInfo& other32) {
  areaId = other32.areaId;
  isOnline = other32.isOnline;
  name = other32.name;
  __isset = other32.__isset;
  return *this;
}
void RoleInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RoleInfo(";
  out << "areaId=" << to_string(areaId);
  out << ", " << "isOnline=" << to_string(isOnline);
  out << ", " << "name=" << to_string(name);
  out << ")";
}


AreaInfo::~AreaInfo() throw() {
}


void AreaInfo::__set_areaId(const int32_t val) {
  this->areaId = val;
}

void AreaInfo::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void AreaInfo::__set_serverList(const std::vector<GameServerInfo> & val) {
  this->serverList = val;
__isset.serverList = true;
}

void AreaInfo::__set_currentCnt(const int32_t val) {
  this->currentCnt = val;
}

uint32_t AreaInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->areaId);
          this->__isset.areaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serverList.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->serverList.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->serverList[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serverList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->currentCnt);
          this->__isset.currentCnt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AreaInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AreaInfo");

  xfer += oprot->writeFieldBegin("areaId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->areaId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serverList) {
    xfer += oprot->writeFieldBegin("serverList", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serverList.size()));
      std::vector<GameServerInfo> ::const_iterator _iter38;
      for (_iter38 = this->serverList.begin(); _iter38 != this->serverList.end(); ++_iter38)
      {
        xfer += (*_iter38).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("currentCnt", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->currentCnt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AreaInfo &a, AreaInfo &b) {
  using ::std::swap;
  swap(a.areaId, b.areaId);
  swap(a.name, b.name);
  swap(a.serverList, b.serverList);
  swap(a.currentCnt, b.currentCnt);
  swap(a.__isset, b.__isset);
}

AreaInfo::AreaInfo(const AreaInfo& other39) {
  areaId = other39.areaId;
  name = other39.name;
  serverList = other39.serverList;
  currentCnt = other39.currentCnt;
  __isset = other39.__isset;
}
AreaInfo& AreaInfo::operator=(const AreaInfo& other40) {
  areaId = other40.areaId;
  name = other40.name;
  serverList = other40.serverList;
  currentCnt = other40.currentCnt;
  __isset = other40.__isset;
  return *this;
}
void AreaInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AreaInfo(";
  out << "areaId=" << to_string(areaId);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "serverList="; (__isset.serverList ? (out << to_string(serverList)) : (out << "<null>"));
  out << ", " << "currentCnt=" << to_string(currentCnt);
  out << ")";
}


Order::~Order() throw() {
}


void Order::__set_roleId(const std::string& val) {
  this->roleId = val;
}

void Order::__set_orderId(const std::string& val) {
  this->orderId = val;
}

void Order::__set_type(const std::string& val) {
  this->type = val;
}

void Order::__set_goodsCode(const std::string& val) {
  this->goodsCode = val;
}

void Order::__set_price(const double val) {
  this->price = val;
}

void Order::__set_state(const std::string& val) {
  this->state = val;
}

void Order::__set_createAt(const int64_t val) {
  this->createAt = val;
__isset.createAt = true;
}

void Order::__set_payAt(const int64_t val) {
  this->payAt = val;
__isset.payAt = true;
}

uint32_t Order::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roleId);
          this->__isset.roleId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orderId);
          this->__isset.orderId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->goodsCode);
          this->__isset.goodsCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createAt);
          this->__isset.createAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->payAt);
          this->__isset.payAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Order::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Order");

  xfer += oprot->writeFieldBegin("roleId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->roleId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orderId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->orderId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("goodsCode", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->goodsCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.createAt) {
    xfer += oprot->writeFieldBegin("createAt", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->createAt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.payAt) {
    xfer += oprot->writeFieldBegin("payAt", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->payAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Order &a, Order &b) {
  using ::std::swap;
  swap(a.roleId, b.roleId);
  swap(a.orderId, b.orderId);
  swap(a.type, b.type);
  swap(a.goodsCode, b.goodsCode);
  swap(a.price, b.price);
  swap(a.state, b.state);
  swap(a.createAt, b.createAt);
  swap(a.payAt, b.payAt);
  swap(a.__isset, b.__isset);
}

Order::Order(const Order& other41) {
  roleId = other41.roleId;
  orderId = other41.orderId;
  type = other41.type;
  goodsCode = other41.goodsCode;
  price = other41.price;
  state = other41.state;
  createAt = other41.createAt;
  payAt = other41.payAt;
  __isset = other41.__isset;
}
Order& Order::operator=(const Order& other42) {
  roleId = other42.roleId;
  orderId = other42.orderId;
  type = other42.type;
  goodsCode = other42.goodsCode;
  price = other42.price;
  state = other42.state;
  createAt = other42.createAt;
  payAt = other42.payAt;
  __isset = other42.__isset;
  return *this;
}
void Order::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Order(";
  out << "roleId=" << to_string(roleId);
  out << ", " << "orderId=" << to_string(orderId);
  out << ", " << "type=" << to_string(type);
  out << ", " << "goodsCode=" << to_string(goodsCode);
  out << ", " << "price=" << to_string(price);
  out << ", " << "state=" << to_string(state);
  out << ", " << "createAt="; (__isset.createAt ? (out << to_string(createAt)) : (out << "<null>"));
  out << ", " << "payAt="; (__isset.payAt ? (out << to_string(payAt)) : (out << "<null>"));
  out << ")";
}


